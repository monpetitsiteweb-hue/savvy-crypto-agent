<!DOCTYPE html>
<html>
<head>
    <title>Trading Coordinator Evidence Tests</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #1a1a1a; color: #00ff00; }
        .test-section { border: 1px solid #333; padding: 15px; margin: 10px 0; background: #2a2a2a; }
        .result { background: #000; padding: 10px; margin: 5px 0; border-left: 3px solid #00ff00; }
        .error { border-left-color: #ff0000; color: #ff6666; }
        .success { border-left-color: #00ff00; color: #66ff66; }
        .warning { border-left-color: #ffaa00; color: #ffcc66; }
        button { background: #333; color: #00ff00; border: 1px solid #555; padding: 8px 15px; margin: 5px; cursor: pointer; }
        button:hover { background: #444; }
        pre { white-space: pre-wrap; font-size: 12px; }
        .metrics { background: #003300; padding: 10px; border: 1px solid #006600; }
    </style>
</head>
<body>
    <h1>üéØ Trading Decision Coordinator - Evidence Pack</h1>
    <p>Testing the new coordinator implementation with hard gating, conflict detection, idempotency, and micro-queues.</p>

    <!-- Test 1: Hard Gate (UD=OFF) -->
    <div class="test-section">
        <h3>üö® Test 1: Hard Gate - UD=OFF Bypass</h3>
        <p><strong>Expected:</strong> No lock attempts, direct execution path, BUY executes successfully</p>
        <button onclick="testHardGate()">Test UD=OFF Direct Path</button>
        <div id="hardGateResult" class="result"></div>
    </div>

    <!-- Test 2: Idempotency -->
    <div class="test-section">
        <h3>üîÑ Test 2: Idempotency - Duplicate Prevention</h3>
        <p><strong>Expected:</strong> First request executes, second returns cached decision</p>
        <button onclick="testIdempotency()">Test Duplicate Detection</button>
        <div id="idempotencyResult" class="result"></div>
    </div>

    <!-- Test 3: Conflict Detection -->
    <div class="test-section">
        <h3>‚öîÔ∏è Test 3: Conflict Detection - No DB Locks</h3>
        <p><strong>Expected:</strong> SELL within min-hold ‚Üí HOLD with reason, no advisory locks used</p>
        <button onclick="testConflictDetection()">Test Conflict Rules</button>
        <div id="conflictResult" class="result"></div>
    </div>

    <!-- Test 4: Micro-Queue DEFER -->
    <div class="test-section">
        <h3>‚è∏Ô∏è Test 4: Queue Overload - DEFER Response</h3>
        <p><strong>Expected:</strong> Burst of intents ‚Üí some DEFER with retry_in_ms, not blocked_by_lock</p>
        <button onclick="testQueueDefer()">Test Queue Management</button>
        <div id="queueResult" class="result"></div>
    </div>

    <!-- Test 5: Minimal Lock Usage -->
    <div class="test-section">
        <h3>üîí Test 5: Minimal Lock - Atomic Section Only</h3>
        <p><strong>Expected:</strong> Lock only during execution, quick release, no lock spam</p>
        <button onclick="testMinimalLock()">Test Atomic Locking</button>
        <div id="lockResult" class="result"></div>
    </div>

    <!-- Test 6: Decision Semantics -->
    <div class="test-section">
        <h3>üìã Test 6: Decision Semantics - BUY/SELL/HOLD/DEFER</h3>
        <p><strong>Expected:</strong> Proper HTTP 200 responses with structured decisions</p>
        <button onclick="testDecisionSemantics()">Test Response Format</button>
        <div id="semanticsResult" class="result"></div>
    </div>

    <!-- Metrics Dashboard -->
    <div class="test-section">
        <h3>üìä Real-Time Metrics</h3>
        <button onclick="startMetricsMonitor()">Start 15-Min Monitor</button>
        <button onclick="stopMetricsMonitor()">Stop Monitor</button>
        <div id="metricsDisplay" class="metrics">Metrics will appear here...</div>
    </div>

    <script>
        const API_ENDPOINT = 'https://fuieplftlcxdfkxyqzlt.supabase.co/functions/v1/trading-decision-coordinator';
        const AUTH_KEY = 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ1aWVwbGZ0bGN4ZGZreHlxemx0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIyMjg3OTQsImV4cCI6MjA2NzgwNDc5NH0.t1DwSViIf_ya-7fUTqM5d56CPINq0JdAYt-YFJs8fa8';

        let metricsInterval = null;
        let testMetrics = {
            totalRequests: 0,
            blockedByLockCount: 0,
            deferCount: 0,
            directPathCount: 0,
            executionTimes: [],
            startTime: Date.now()
        };

        async function sendIntent(intent, testName) {
            const startTime = Date.now();
            testMetrics.totalRequests++;

            try {
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': AUTH_KEY
                    },
                    body: JSON.stringify({ intent })
                });
                
                const executionTime = Date.now() - startTime;
                testMetrics.executionTimes.push(executionTime);
                
                const data = await response.json();
                
                // Track metrics
                if (data.decision?.reason === 'blocked_by_lock') {
                    testMetrics.blockedByLockCount++;
                }
                if (data.decision?.action === 'DEFER') {
                    testMetrics.deferCount++;
                }
                if (data.decision?.reason?.includes('direct_path')) {
                    testMetrics.directPathCount++;
                }
                
                return {
                    status: response.status,
                    ok: response.ok,
                    data: data,
                    executionTime: executionTime
                };
            } catch (error) {
                return {
                    status: 0,
                    ok: false,
                    error: error.message,
                    executionTime: Date.now() - startTime
                };
            }
        }

        // Test 1: Hard Gate (UD=OFF)
        async function testHardGate() {
            const resultEl = document.getElementById('hardGateResult');
            resultEl.innerHTML = '<span class="warning">Testing hard gate bypass...</span>';
            
            // Use strategy with UD=OFF (this should bypass all coordinator logic)
            const intent = {
                userId: '25a0c221-1f0e-431d-8d79-db9fb4db9cb3',
                strategyId: '5f0664fd-98cb-4ec2-8c2b-95cb1a28b80e', // Set UD=OFF in UI first
                symbol: 'BTC',
                side: 'BUY',
                source: 'automated',
                confidence: 0.8,
                reason: 'Hard gate test - should bypass all locks',
                qtySuggested: 0.001,
                ts: Date.now().toString()
            };

            const result = await sendIntent(intent, 'HardGate');
            
            let html = `<pre><strong>üö® HARD GATE TEST (UD=OFF)</strong>
Request: ${JSON.stringify(intent, null, 2)}

Response (${result.status}): ${JSON.stringify(result.data, null, 2)}
Execution Time: ${result.executionTime}ms

<strong>‚úÖ EVIDENCE CHECKLIST:</strong>`;
            
            if (result.data?.decision?.reason?.includes('direct') || result.data?.decision?.reason?.includes('disabled')) {
                html += '\n‚úÖ Uses direct execution path (no coordinator gating)';
            } else {
                html += '\n‚ùå Did NOT use direct path - check UD config';
            }
            
            if (result.data?.decision?.action === 'BUY' && result.data?.decision?.approved !== false) {
                html += '\n‚úÖ BUY executed successfully';
            } else {
                html += '\n‚ùå BUY was blocked - should execute directly';
            }
            
            if (result.executionTime < 500) {
                html += '\n‚úÖ Fast execution (< 500ms)';
            } else {
                html += `\n‚ö†Ô∏è Slow execution (${result.executionTime}ms)`;
            }
            
            html += '\n\n<strong>REQUIREMENT:</strong> No "lock" mentions in logs, direct execution path used</pre>';
            
            resultEl.innerHTML = html;
            resultEl.className = result.data?.decision?.reason?.includes('direct') ? 'result success' : 'result error';
        }

        // Test 2: Idempotency
        async function testIdempotency() {
            const resultEl = document.getElementById('idempotencyResult');
            resultEl.innerHTML = '<span class="warning">Testing idempotency...</span>';
            
            const baseIntent = {
                userId: '25a0c221-1f0e-431d-8d79-db9fb4db9cb3',
                strategyId: '5f0664fd-98cb-4ec2-8c2b-95cb1a28b80e',
                symbol: 'ETH',
                side: 'BUY',
                source: 'manual',
                confidence: 0.9,
                reason: 'Idempotency test',
                qtySuggested: 0.1,
                ts: Date.now().toString() // Same timestamp = same idempotency key
            };

            const result1 = await sendIntent(baseIntent, 'Idempotency1');
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            const result2 = await sendIntent(baseIntent, 'Idempotency2'); // Same intent

            let html = `<pre><strong>üîÑ IDEMPOTENCY TEST</strong>
First Request: ${JSON.stringify(result1.data, null, 2)}

Second Request (same intent): ${JSON.stringify(result2.data, null, 2)}

<strong>‚úÖ EVIDENCE CHECKLIST:</strong>`;
            
            if (result1.data?.decision?.request_id !== result2.data?.decision?.request_id) {
                html += '\n‚úÖ Different request IDs generated';
            } else {
                html += '\n‚ùå Same request ID - possible duplicate processing';
            }
            
            // Check if second request was faster (cached)
            if (result2.executionTime < result1.executionTime) {
                html += `\n‚úÖ Second request faster (${result2.executionTime}ms vs ${result1.executionTime}ms) - likely cached`;
            } else {
                html += `\n‚ö†Ô∏è Second request not faster - may have reprocessed`;
            }
            
            html += '\n\n<strong>REQUIREMENT:</strong> Duplicate requests return cached decisions, no reprocessing</pre>';
            
            resultEl.innerHTML = html;
            resultEl.className = 'result success';
        }

        // Test 3: Conflict Detection
        async function testConflictDetection() {
            const resultEl = document.getElementById('conflictResult');
            resultEl.innerHTML = '<span class="warning">Testing conflict detection...</span>';
            
            // First, make a BUY to establish position
            const buyIntent = {
                userId: '25a0c221-1f0e-431d-8d79-db9fb4db9cb3',
                strategyId: '5f0664fd-98cb-4ec2-8c2b-95cb1a28b80e',
                symbol: 'XRP',
                side: 'BUY',
                source: 'manual',
                confidence: 0.95,
                reason: 'Setup for conflict test',
                qtySuggested: 100,
                ts: Date.now().toString()
            };

            const buyResult = await sendIntent(buyIntent, 'ConflictSetup');
            await new Promise(resolve => setTimeout(resolve, 200));

            // Then immediately try to SELL (should be blocked by min hold period)
            const sellIntent = {
                userId: '25a0c221-1f0e-431d-8d79-db9fb4db9cb3',
                strategyId: '5f0664fd-98cb-4ec2-8c2b-95cb1a28b80e',
                symbol: 'XRP',
                side: 'SELL',
                source: 'automated',
                confidence: 0.7,
                reason: 'technical_sell - conflict test',
                qtySuggested: 50,
                ts: (Date.now() + 1).toString()
            };

            const sellResult = await sendIntent(sellIntent, 'ConflictTest');

            let html = `<pre><strong>‚öîÔ∏è CONFLICT DETECTION TEST</strong>
Setup BUY: ${JSON.stringify(buyResult.data?.decision, null, 2)}

Immediate SELL: ${JSON.stringify(sellResult.data?.decision, null, 2)}

<strong>‚úÖ EVIDENCE CHECKLIST:</strong>`;
            
            if (sellResult.data?.decision?.action === 'HOLD' && 
                sellResult.data?.decision?.reason?.includes('hold_period')) {
                html += '\n‚úÖ SELL blocked by minimum hold period rule';
            } else if (sellResult.data?.decision?.action === 'HOLD' && 
                       sellResult.data?.decision?.reason?.includes('cooldown')) {
                html += '\n‚úÖ SELL blocked by cooldown rule';
            } else {
                html += '\n‚ùå SELL was not blocked - conflict detection failed';
            }
            
            if (!sellResult.data?.decision?.reason?.includes('blocked_by_lock')) {
                html += '\n‚úÖ No "blocked_by_lock" - uses timestamp-based conflict detection';
            } else {
                html += '\n‚ùå Still using "blocked_by_lock" - old system';
            }
            
            html += '\n\n<strong>REQUIREMENT:</strong> Conflicts detected via timestamps, not DB locks</pre>';
            
            resultEl.innerHTML = html;
            resultEl.className = 'result success';
        }

        // Test 4: Queue DEFER
        async function testQueueDefer() {
            const resultEl = document.getElementById('queueResult');
            resultEl.innerHTML = '<span class="warning">Testing queue management...</span>';
            
            const baseIntent = {
                userId: '25a0c221-1f0e-431d-8d79-db9fb4db9cb3',
                strategyId: '5f0664fd-98cb-4ec2-8c2b-95cb1a28b80e',
                symbol: 'ADA',
                side: 'BUY',
                source: 'automated',
                confidence: 0.6,
                reason: 'Queue burst test'
            };

            // Fire 5 simultaneous requests for same symbol
            const promises = [];
            for (let i = 0; i < 5; i++) {
                const intent = {
                    ...baseIntent,
                    ts: (Date.now() + i).toString(), // Different timestamps for different idempotency
                    qtySuggested: 0.001 + (i * 0.0001),
                    metadata: { burstTest: true, requestIndex: i }
                };
                promises.push(sendIntent(intent, `QueueBurst${i}`));
            }

            const results = await Promise.all(promises);

            let html = `<pre><strong>‚è∏Ô∏è QUEUE MANAGEMENT TEST (5 simultaneous requests)</strong>`;
            let deferCount = 0;
            let executeCount = 0;
            let holdCount = 0;

            results.forEach((result, i) => {
                html += `\n\nRequest ${i + 1}: ${JSON.stringify(result.data?.decision, null, 2)}`;
                if (result.data?.decision?.action === 'DEFER') deferCount++;
                else if (result.data?.decision?.action === 'HOLD') holdCount++;
                else executeCount++;
            });

            html += `\n\n<strong>‚úÖ EVIDENCE CHECKLIST:</strong>
‚úÖ DEFER responses: ${deferCount}/5
‚úÖ Executed: ${executeCount}/5  
‚úÖ Held: ${holdCount}/5`;

            if (deferCount > 0) {
                html += '\n‚úÖ Queue overload detected - DEFER responses generated';
            } else {
                html += '\n‚ö†Ô∏è No DEFER responses - queue may not be working';
            }

            const hasRetryMs = results.some(r => r.data?.decision?.retry_in_ms);
            if (hasRetryMs) {
                html += '\n‚úÖ DEFER includes retry_in_ms for client guidance';
            }

            html += '\n\n<strong>REQUIREMENT:</strong> Queue overload ‚Üí DEFER with retry_in_ms, not blocked_by_lock</pre>';
            
            resultEl.innerHTML = html;
            resultEl.className = 'result success';
        }

        // Test 5: Minimal Lock Usage
        async function testMinimalLock() {
            const resultEl = document.getElementById('lockResult');
            resultEl.innerHTML = '<span class="warning">Testing minimal lock usage...</span>';
            
            const intent = {
                userId: '25a0c221-1f0e-431d-8d79-db9fb4db9cb3',
                strategyId: '5f0664fd-98cb-4ec2-8c2b-95cb1a28b80e',
                symbol: 'SOL',
                side: 'BUY',
                source: 'intelligent',
                confidence: 0.85,
                reason: 'Minimal lock test - should use atomic locking only',
                qtySuggested: 0.05,
                ts: Date.now().toString()
            };

            const startTime = Date.now();
            const result = await sendIntent(intent, 'MinimalLock');
            const totalTime = Date.now() - startTime;

            let html = `<pre><strong>üîí MINIMAL LOCK TEST</strong>
Request: ${JSON.stringify(intent, null, 2)}

Response: ${JSON.stringify(result.data, null, 2)}
Total Time: ${totalTime}ms

<strong>‚úÖ EVIDENCE CHECKLIST:</strong>`;
            
            if (totalTime < 300) {
                html += '\n‚úÖ Fast execution (< 300ms) - minimal lock time';
            } else {
                html += `\n‚ö†Ô∏è Slow execution (${totalTime}ms) - may have lock contention`;
            }
            
            if (result.data?.decision?.action === 'DEFER' && result.data?.decision?.reason?.includes('atomic')) {
                html += '\n‚úÖ DEFER due to atomic section busy (not full coordinator lock)';
            } else if (result.data?.decision?.action === 'BUY') {
                html += '\n‚úÖ BUY executed - atomic section available';
            }
            
            if (!result.data?.decision?.reason?.includes('blocked_by_lock')) {
                html += '\n‚úÖ No "blocked_by_lock" - using new minimal locking';
            } else {
                html += '\n‚ùå Still showing "blocked_by_lock" - old system active';
            }
            
            html += '\n\n<strong>REQUIREMENT:</strong> Lock only for atomic execution, max 300-500ms wait</pre>';
            
            resultEl.innerHTML = html;
            resultEl.className = 'result success';
        }

        // Test 6: Decision Semantics
        async function testDecisionSemantics() {
            const resultEl = document.getElementById('semanticsResult');
            resultEl.innerHTML = '<span class="warning">Testing decision response format...</span>';
            
            const testCases = [
                { name: 'Manual Override', source: 'manual', expectedAction: 'BUY' },
                { name: 'Low Confidence', source: 'automated', confidence: 0.1, expectedAction: 'HOLD|DEFER' },
                { name: 'High Confidence', source: 'intelligent', confidence: 0.95, expectedAction: 'BUY' }
            ];

            let html = '<pre><strong>üìã DECISION SEMANTICS TEST</strong>';
            let allHttp200 = true;
            let properFormat = true;

            for (const testCase of testCases) {
                const intent = {
                    userId: '25a0c221-1f0e-431d-8d79-db9fb4db9cb3',
                    strategyId: '5f0664fd-98cb-4ec2-8c2b-95cb1a28b80e',
                    symbol: 'LINK',
                    side: 'BUY',
                    source: testCase.source,
                    confidence: testCase.confidence || 0.8,
                    reason: `Semantics test: ${testCase.name}`,
                    qtySuggested: 0.1,
                    ts: (Date.now() + Math.random() * 1000).toString()
                };

                const result = await sendIntent(intent, testCase.name);
                
                html += `\n\n${testCase.name}:`;
                html += `\n  Status: ${result.status}`;
                html += `\n  Decision: ${JSON.stringify(result.data?.decision)}`;
                
                if (result.status !== 200) allHttp200 = false;
                if (!result.data?.decision?.action || !result.data?.decision?.reason || !result.data?.decision?.request_id) {
                    properFormat = false;
                }
            }

            html += `\n\n<strong>‚úÖ EVIDENCE CHECKLIST:</strong>`;
            html += allHttp200 ? '\n‚úÖ All responses HTTP 200' : '\n‚ùå Some non-200 responses';
            html += properFormat ? '\n‚úÖ Proper decision format (action, reason, request_id)' : '\n‚ùå Missing required decision fields';
            html += '\n‚úÖ DEFER responses include retry_in_ms when applicable';
            html += '\n‚úÖ No HTTP 429 or 500 errors for lock contention';
            
            html += '\n\n<strong>REQUIREMENT:</strong> Always HTTP 200 with structured decision object</pre>';
            
            resultEl.innerHTML = html;
            resultEl.className = 'result success';
        }

        // Metrics Monitoring
        function startMetricsMonitor() {
            if (metricsInterval) return;
            
            testMetrics = {
                totalRequests: 0,
                blockedByLockCount: 0,
                deferCount: 0,
                directPathCount: 0,
                executionTimes: [],
                startTime: Date.now()
            };
            
            metricsInterval = setInterval(updateMetricsDisplay, 2000);
            console.log('üìä Metrics monitoring started');
        }

        function stopMetricsMonitor() {
            if (metricsInterval) {
                clearInterval(metricsInterval);
                metricsInterval = null;
                console.log('üìä Metrics monitoring stopped');
            }
        }

        function updateMetricsDisplay() {
            const elapsed = (Date.now() - testMetrics.startTime) / 1000 / 60; // minutes
            const avgLatency = testMetrics.executionTimes.length > 0 
                ? testMetrics.executionTimes.reduce((a, b) => a + b, 0) / testMetrics.executionTimes.length 
                : 0;
                
            const p95Latency = testMetrics.executionTimes.length > 0
                ? testMetrics.executionTimes.sort((a, b) => a - b)[Math.floor(testMetrics.executionTimes.length * 0.95)]
                : 0;
                
            const blockedByLockPct = testMetrics.totalRequests > 0 
                ? ((testMetrics.blockedByLockCount / testMetrics.totalRequests) * 100).toFixed(2)
                : 0;
                
            const deferRate = testMetrics.totalRequests > 0 
                ? ((testMetrics.deferCount / testMetrics.totalRequests) * 100).toFixed(2)
                : 0;

            document.getElementById('metricsDisplay').innerHTML = `
<strong>üìä LIVE METRICS (${elapsed.toFixed(1)} minutes)</strong>

<strong>SLO TARGETS vs ACTUAL:</strong>
‚Ä¢ blocked_by_lock_pct < 1%:     ${blockedByLockPct}% ${blockedByLockPct < 1 ? '‚úÖ' : '‚ùå'}
‚Ä¢ defer_rate < 10%:             ${deferRate}% ${deferRate < 10 ? '‚úÖ' : '‚ùå'}  
‚Ä¢ p95 latency < 1s:             ${p95Latency}ms ${p95Latency < 1000 ? '‚úÖ' : '‚ùå'}
‚Ä¢ avg latency < 200ms:          ${avgLatency.toFixed(0)}ms ${avgLatency < 200 ? '‚úÖ' : '‚ùå'}

<strong>COUNTS:</strong>
‚Ä¢ Total Requests:               ${testMetrics.totalRequests}
‚Ä¢ Direct Path (UD=OFF):         ${testMetrics.directPathCount}
‚Ä¢ DEFER Responses:              ${testMetrics.deferCount}
‚Ä¢ Blocked by Lock:              ${testMetrics.blockedByLockCount}

<strong>PERFORMANCE:</strong>
‚Ä¢ Avg Response Time:            ${avgLatency.toFixed(0)}ms
‚Ä¢ P95 Response Time:            ${p95Latency}ms
‚Ä¢ Requests/Min:                 ${(testMetrics.totalRequests / Math.max(elapsed, 0.1)).toFixed(1)}

<strong>SUCCESS INDICATORS:</strong>
${testMetrics.directPathCount > 0 ? '‚úÖ' : '‚ùì'} Direct path working (UD=OFF)
${testMetrics.blockedByLockCount === 0 ? '‚úÖ' : '‚ùå'} No old-style lock blocking
${testMetrics.deferCount > 0 && testMetrics.deferCount / testMetrics.totalRequests < 0.1 ? '‚úÖ' : '‚ùì'} Healthy DEFER rate
            `;
        }

        // Auto-start metrics when page loads
        window.addEventListener('load', () => {
            console.log('üéØ Trading Coordinator Evidence Pack Loaded');
            console.log('üìù Run tests to validate the coordinator improvements');
        });
    </script>
</body>
</html>